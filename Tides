<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tide Chart Widget</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* Dark background for the page */
        }
        .tide-chart-container {
            touch-action: manipulation;
        }
        .axis path,
        .axis line {
            stroke: #4b5563;
        }
        .axis text {
            fill: #d1d5db;
            font-size: 0.75rem;
        }
        .grid path {
            stroke: none;
        }
        .grid line {
            stroke: #4b5563; /* Darker grey */
            stroke-opacity: 0.7; /* A bit more visible */
            shape-rendering: crispEdges;
        }
        .event-label {
            font-size: 0.7rem;
            fill: #f3f4f6;
        }
         .event-label-box {
            fill: rgba(17, 24, 39, 0.7);
            stroke: #4b5563;
            stroke-width: 1px;
        }
        /* Style for the SVG container to be responsive */
        #chart-container svg {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body class="p-4">

    <div class="tide-chart-container bg-gray-800 text-white rounded-2xl shadow-2xl p-4 sm:p-6 w-full max-w-[600px] mx-auto border border-gray-700">
        <!-- Header: Location, Date, and Navigation -->
        <div class="flex justify-between items-center mb-4">
            <button id="prev-day" class="p-2 rounded-full hover:bg-gray-700 transition-colors duration-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                </svg>
            </button>
            <div class="text-center">
                <p id="current-date" class="text-lg sm:text-xl text-gray-300"></p>
                <p id="next-tide-event" class="text-sm sm:text-base text-gray-400 mt-1"></p>
            </div>
            <button id="next-day" class="p-2 rounded-full hover:bg-gray-700 transition-colors duration-200">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>
            </button>
        </div>

        <!-- SVG Container for the Chart -->
        <div id="chart-container" class="relative w-full h-[300px]"></div>
        
        <!-- Tooltip for Hover Interaction -->
        <div id="tooltip" class="absolute pointer-events-none opacity-0 transition-opacity duration-200 bg-gray-900 bg-opacity-80 backdrop-blur-sm text-white text-sm rounded-lg px-3 py-2 shadow-lg">
            <p id="tooltip-time"></p>
            <p id="tooltip-height" class="font-bold"></p>
        </div>

    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURATION ---
            const initialDate = new Date('2025-09-05T10:18:00-07:00'); // Use PDT timezone
            const DANGEROUS_LOW_TIDE = 1.5; // in feet

            // --- STATE ---
            const chartContainer = d3.select("#chart-container");
            const tooltip = d3.select("#tooltip");
            const dateDisplay = document.getElementById('current-date');
            const nextTideDisplay = document.getElementById('next-tide-event');
            let currentDate = new Date(initialDate);
            let countdownInterval = null;
            const tideDataCache = {};
            const NOAA_STATION_ID = "9414816"; // Richmond, CA

            // Fetch tide data from NOAA's API
            async function fetchTideData(date) {
                const dateString = date.toISOString().split('T')[0];
                if (tideDataCache[dateString]) return tideDataCache[dateString];

                const yyyymmdd = date.getFullYear() + ('0' + (date.getMonth() + 1)).slice(-2) + ('0' + date.getDate()).slice(-2);
                const url = `https://api.tidesandcurrents.noaa.gov/api/prod/datagetter?product=predictions&application=NOS.CO-OPS.CAT&begin_date=${yyyymmdd}&end_date=${yyyymmdd}&datum=MLLW&station=${NOAA_STATION_ID}&time_zone=lst_ldt&units=english&format=json`;

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`NOAA API request failed: ${response.statusText}`);
                    }
                    const data = await response.json();
                    if (!data.predictions) {
                         // This can happen if NOAA has no data for the requested date (e.g., too far in future)
                        throw new Error("No predictions found in NOAA response.");
                    }
                    const formattedData = data.predictions.map(p => ({
                        time: new Date(p.t),
                        height: parseFloat(p.v)
                    }));
                    tideDataCache[dateString] = formattedData;
                    return formattedData;
                } catch (error) {
                    console.error("Failed to fetch tide data:", error);
                    return null; // Return null to indicate failure
                }
            }
            
            // Finds the high and low tide events from a dense data array
            function findTideExtremes(tideData) {
                if (!tideData || tideData.length < 3) return [];
                const extremes = [];
                let direction = 0; // 0 = flat, 1 = rising, -1 = falling

                // Find initial direction
                for (let i = 1; i < tideData.length; i++) {
                    const diff = tideData[i].height - tideData[i-1].height;
                    if (diff > 0) { direction = 1; break; }
                    if (diff < 0) { direction = -1; break; }
                }

                for (let i = 1; i < tideData.length - 1; i++) {
                    const prev = tideData[i - 1].height;
                    const current = tideData[i].height;
                    const next = tideData[i + 1].height;

                    const newDirection = (next - current) > 0 ? 1 : (next - current) < 0 ? -1 : direction;

                    if (direction === 1 && newDirection === -1) {
                        // Switched from rising to falling -> High Tide
                        extremes.push({ type: 'High', ...tideData[i] });
                    } else if (direction === -1 && newDirection === 1) {
                        // Switched from falling to rising -> Low Tide
                        extremes.push({ type: 'Low', ...tideData[i] });
                    }
                    
                    // Update direction if it has changed
                    if(newDirection !== 0) {
                       direction = newDirection;
                    }
                }
                return extremes;
            }

            // --- CORE DRAWING FUNCTION ---
            async function drawChart() {
                chartContainer.html("<div class='text-gray-400 flex items-center justify-center h-full'>Loading tide data...</div>"); // Show loading message

                const prevDay = new Date(currentDate);
                prevDay.setDate(prevDay.getDate() - 1);
                const nextDay = new Date(currentDate);
                nextDay.setDate(nextDay.getDate() + 1);

                const [prevTides, currentTides, nextTides] = await Promise.all([
                    fetchTideData(prevDay),
                    fetchTideData(currentDate),
                    fetchTideData(nextDay)
                ]);
                
                chartContainer.html(""); // Clear loading message

                if (!currentTides) { // We only need the current day's data to draw the chart itself
                    chartContainer.html("<div class='text-red-400 p-4 flex items-center justify-center h-full'>Could not load tide data.</div>");
                    return;
                }
                
                const chartData = currentTides;

                // Use the combined data from all three days to accurately find the turning points
                const allTidesData = [...(prevTides || []), ...currentTides, ...(nextTides || [])];
                const allExtremes = findTideExtremes(allTidesData);

                const startOfDay = d3.timeDay.floor(currentDate);
                const endOfDay = d3.timeDay.ceil(currentDate);
                
                // Filter the events to only those that fall on the current day
                const tideEvents = allExtremes.filter(event => event.time >= startOfDay && event.time < endOfDay);


                // --- 1. SETUP SVG AND DIMENSIONS ---
                const containerRect = chartContainer.node().getBoundingClientRect();
                const margin = { top: 20, right: 20, bottom: 40, left: 45 };
                const width = containerRect.width - margin.left - margin.right;
                const height = containerRect.height - margin.top - margin.bottom;

                const svg = chartContainer.append("svg")
                    .attr("width", containerRect.width)
                    .attr("height", containerRect.height)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);
                
                // --- 2. DEFINE SCALES ---
                const xScale = d3.scaleTime()
                    .domain([startOfDay, endOfDay])
                    .range([0, width]);

                const [minTide, maxTide] = d3.extent(chartData, d => d.height);
                const yScale = d3.scaleLinear()
                    .domain([minTide - 1, maxTide + 1]) // Add 1 foot padding
                    .range([height, 0]);

                // --- 3. CURVE TYPE ---
                const curve = d3.curveBasis; // Use a curve for slight smoothing of discrete points

                // --- 4. DRAW DAY/NIGHT BACKGROUND ---
                // Approximate sunrise/sunset for Berkeley in September
                const sunriseTime = new Date(startOfDay);
                sunriseTime.setHours(6, 45, 0, 0);
                const sunsetTime = new Date(startOfDay);
                sunsetTime.setHours(19, 30, 0, 0);

                svg.append("rect")
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", width)
                    .attr("height", height)
                    .attr("fill", "white"); // Day background

                svg.append("rect") // First night section
                    .attr("x", xScale(startOfDay))
                    .attr("y", 0)
                    .attr("width", xScale(sunriseTime) - xScale(startOfDay))
                    .attr("height", height)
                    .attr("fill", "#374151") // Darker gray
                    .style("opacity", 0.6); // Slightly more opaque

                svg.append("rect") // Second night section
                    .attr("x", xScale(sunsetTime))
                    .attr("y", 0)
                    .attr("width", xScale(endOfDay) - xScale(sunsetTime))
                    .attr("height", height)
                    .attr("fill", "#374151") // Darker gray
                    .style("opacity", 0.6); // Slightly more opaque

                // --- 5. DRAW GRID ---
                // Horizontal grid lines
                svg.append("g")			
                    .attr("class", "grid")
                    .call(d3.axisLeft(yScale)
                        .tickSize(-width)
                        .tickFormat("")
                    );

                // Vertical grid lines
                svg.append("g")			
                    .attr("class", "grid")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(xScale)
                        .ticks(d3.timeHour.every(3))
                        .tickSize(-height)
                        .tickFormat("")
                    );

                // --- 6. DRAW TIDE AREAS ---
                const areaGenerator = (y0) => d3.area()
                    .x(d => xScale(d.time))
                    .y0(y0)
                    .y1(d => yScale(d.height))
                    .curve(curve);

                // Create segments between tide events for accurate coloring
                const eventPoints = [chartData[0], ...tideEvents, chartData[chartData.length - 1]]
                    .sort((a, b) => a.time - b.time)
                    .filter((d, i, arr) => !d || i === 0 || d.time.getTime() !== arr[i-1].time.getTime());

                const segments = [];
                for (let i = 0; i < eventPoints.length - 1; i++) {
                    const startPoint = eventPoints[i];
                    const endPoint = eventPoints[i+1];
                    if (!startPoint || !endPoint) continue;
                    const segmentData = chartData.filter(d => d.time >= startPoint.time && d.time <= endPoint.time);
                    if (segmentData.length > 0) {
                        segments.push({
                            rising: endPoint.height > startPoint.height,
                            data: segmentData
                        });
                    }
                }

                // FIX: Ensure the last segment extends to the edge of the chart to prevent a visual gap.
                if (segments.length > 0 && chartData.length > 0) {
                    const lastSegment = segments[segments.length - 1];
                    const lastDataPoint = chartData[chartData.length - 1];

                    if (lastDataPoint.time < endOfDay) {
                        const endOfDayPoint = { time: endOfDay, height: lastDataPoint.height };
                        lastSegment.data.push(endOfDayPoint);
                    }
                }

                segments.forEach(seg => {
                    svg.append("path")
                        .datum(seg.data)
                        .attr("fill", seg.rising ? "#a5f3fc" : "#0369a1") // Light blue for rising, dark blue for falling
                        .attr("d", areaGenerator(height));
                });
                
                // --- ROBUST RED AREA (Segment Intersection Method) ---
                const redAreaGenerator = d3.area()
                    .x(d => xScale(d.time))
                    .y0(yScale(DANGEROUS_LOW_TIDE)) // Top of the red area is the 1.5ft line
                    .y1(d => yScale(d.height))      // Bottom of the red area is the tide curve
                    .curve(curve);

                const redSegments = [];
                let currentSegment = [];

                for (let i = 0; i < chartData.length; i++) {
                    const d = chartData[i];
                    const prev = i > 0 ? chartData[i - 1] : null;
                    const isBelow = d.height < DANGEROUS_LOW_TIDE;
                    const wasBelow = prev ? prev.height < DANGEROUS_LOW_TIDE : false;

                    if (prev && isBelow !== wasBelow) {
                        // Find intersection point via linear interpolation
                        const t0 = prev.time.getTime();
                        const t1 = d.time.getTime();
                        const h0 = prev.height;
                        const h1 = d.height;
                        const intersectionTime = new Date(t0 + (t1 - t0) * (DANGEROUS_LOW_TIDE - h0) / (h1 - h0));
                        const intersectionPoint = { time: intersectionTime, height: DANGEROUS_LOW_TIDE };

                        if (isBelow) { // Crossing from above to below, start new segment
                            currentSegment.push(intersectionPoint);
                        } else { // Crossing from below to above, end current segment
                            currentSegment.push(intersectionPoint);
                            if (currentSegment.length > 1) {
                                redSegments.push(currentSegment);
                            }
                            currentSegment = [];
                        }
                    }

                    if (isBelow) {
                        currentSegment.push(d);
                    }
                }

                // FIX: If the tide is still below the danger level at the end of the data,
                // extend the red segment to the edge of the chart.
                const lastDataPoint = chartData.length > 0 ? chartData[chartData.length - 1] : null;
                if (lastDataPoint && lastDataPoint.height < DANGEROUS_LOW_TIDE && currentSegment.length > 0) {
                    if (lastDataPoint.time < endOfDay) {
                        const endOfDayPoint = { time: endOfDay, height: lastDataPoint.height };
                        currentSegment.push(endOfDayPoint);
                    }
                }

                if (currentSegment.length > 1) {
                    redSegments.push(currentSegment);
                }

                redSegments.forEach(segment => {
                    svg.append("path")
                        .datum(segment)
                        .attr("fill", "rgba(239, 68, 68, 0.7)")
                        .attr("d", redAreaGenerator); // Use the specific red area generator
                });

                // --- 7. DRAW AXES ---
                const xAxis = d3.axisBottom(xScale)
                    .ticks(d3.timeHour.every(3))
                    .tickFormat(d3.timeFormat("%-I %p"));
                svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(xAxis)
                    .attr("class", "axis x-axis");

                const yAxis = d3.axisLeft(yScale).tickFormat(d => `${d} ft`);
                svg.append("g")
                    .call(yAxis)
                    .attr("class", "axis y-axis");

                // --- 8. DRAW TIDE EVENT LABELS ---
                const eventsGroup = svg.selectAll(".event")
                    .data(tideEvents)
                    .enter().append("g")
                    .attr("class", "event")
                    .attr("transform", d => `translate(${xScale(d.time)},${yScale(d.height)})`);

                eventsGroup.append("rect")
                    .attr("x", -4)
                    .attr("y", -4)
                    .attr("width", 8)
                    .attr("height", 8)
                    .attr("fill", "#f3f4f6")
                    .attr("stroke", "#1f2937")
                    .attr("stroke-width", 1.5);

                eventsGroup.each(function(d) {
                    const group = d3.select(this);
                    const labelText = `${d3.timeFormat("%-I:%M %p")(d.time)} ${d.height.toFixed(2)}ft`;
                    const textNode = group.append("text")
                        .attr("class", "event-label")
                        .attr("dy", "-10px")
                        .attr("text-anchor", "middle")
                        .text(labelText)
                        .node();
                    
                    const textBBox = textNode.getBBox();
                    group.insert("rect", "text")
                        .attr("class", "event-label-box")
                        .attr("x", textBBox.x - 4)
                        .attr("y", textBBox.y - 2)
                        .attr("width", textBBox.width + 8)
                        .attr("height", textBBox.height + 4)
                        .attr("rx", 4);
                });

                // --- 9. DRAW CURRENT TIME INDICATOR ---
                const now = new Date();
                // For demonstration, use the initialDate on the first load if it matches today.
                const isInitialDay = currentDate.toDateString() === initialDate.toDateString();
                const timeToShow = isInitialDay ? initialDate : now;
                
                if (timeToShow >= startOfDay && timeToShow <= endOfDay) {
                    const nowX = xScale(timeToShow);
                    svg.append("line")
                        .attr("x1", nowX)
                        .attr("x2", nowX)
                        .attr("y1", 0)
                        .attr("y2", height)
                        .attr("stroke", "#facc15") // Yellow
                        .attr("stroke-width", 2)
                        .attr("stroke-dasharray", "4 4");

                    svg.append("circle")
                       .attr("cx", nowX)
                       .attr("cy", 0)
                       .attr("r", 5)
                       .attr("fill", "#facc15");
                }
                
                // --- 10. SETUP HOVER INTERACTION ---
                const hoverGroup = svg.append("g")
                    .attr("class", "hover-group")
                    .style("display", "none");

                const hoverLine = hoverGroup.append("line")
                    .attr("stroke", "#9ca3af")
                    .attr("stroke-width", 1)
                    .attr("y1", 0)
                    .attr("y2", height);
                
                const hoverCircle = hoverGroup.append("circle")
                    .attr("r", 5)
                    .attr("fill", "none")
                    .attr("stroke", "#f3f4f6")
                    .attr("stroke-width", 2);

                svg.append("rect") // Invisible overlay for event capture
                    .attr("width", width)
                    .attr("height", height)
                    .attr("fill", "none")
                    .attr("pointer-events", "all")
                    .on("mouseover", () => {
                        hoverGroup.style("display", null);
                        tooltip.style("opacity", 1);
                    })
                    .on("mouseout", () => {
                        hoverGroup.style("display", "none");
                        tooltip.style("opacity", 0);
                    })
                    .on("mousemove", (event) => {
                        const [mx] = d3.pointer(event);
                        const time = xScale.invert(mx);

                        const bisect = d3.bisector(d => d.time).left;
                        const index = bisect(chartData, time, 1);
                        const a = chartData[index - 1];
                        const b = chartData[index];
                        
                        let d;
                        if (!a) { d = b; } 
                        else if (!b) { d = a; } 
                        else { d = (time - a.time > b.time - time) ? b : a; }

                        if(!d) return;

                        const heightAtTime = d.height;
                        hoverGroup.attr("transform", `translate(${xScale(d.time)}, 0)`);
                        hoverCircle.attr("cy", yScale(heightAtTime));

                        tooltip
                            .style("left", `${event.pageX + 15}px`)
                            .style("top", `${event.pageY - 15}px`);
                        tooltip.select("#tooltip-time").text(d3.timeFormat("%-I:%M %p")(d.time));
                        tooltip.select("#tooltip-height").text(`${heightAtTime.toFixed(2)} ft`);
                    });

                // --- 11. UPDATE UI AND START COUNTDOWN ---
                updateUI();
            }

            // --- UI UPDATE AND EVENT HANDLING ---
            function updateUI() {
                dateDisplay.textContent = currentDate.toLocaleString(undefined, {
                    weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
                });
                
                if(countdownInterval) clearInterval(countdownInterval); // Always clear the old interval

                // The "current day" for the demo is the day of the initialDate.
                const isCurrentDay = currentDate.toDateString() === initialDate.toDateString();

                if (isCurrentDay) {
                    nextTideDisplay.style.display = 'block';
                    updateNextTideEvent(); // Update once immediately
                    countdownInterval = setInterval(updateNextTideEvent, 1000);
                } else {
                    nextTideDisplay.style.display = 'none'; // Hide on other days
                }
            }

            async function updateNextTideEvent() {
                 const now = new Date(); // Use the actual live time for a real countdown

                const prevDay = new Date(currentDate);
                prevDay.setDate(prevDay.getDate() - 1);
                const nextDay = new Date(currentDate);
                nextDay.setDate(nextDay.getDate() + 1);
                
                const [prevTides, currentTides, nextTides] = await Promise.all([
                    fetchTideData(prevDay),
                    fetchTideData(currentDate),
                    fetchTideData(nextDay)
                ]);

                if (!prevTides || !currentTides || !nextTides) {
                    nextTideDisplay.textContent = "Could not calculate next tide event.";
                    return;
                }

                const allTides = [
                    ...findTideExtremes(prevTides),
                    ...findTideExtremes(currentTides),
                    ...findTideExtremes(nextTides)
                ].sort((a,b) => a.time - b.time);

                const nextEvent = allTides.find(event => event.time > now);

                if (nextEvent) {
                    const diff = nextEvent.time - now;
                    const hours = Math.floor(diff / 3600000);
                    const minutes = Math.floor((diff % 3600000) / 60000);
                    const seconds = Math.floor((diff % 60000) / 1000);

                    nextTideDisplay.textContent = `Next ${nextEvent.type} tide in ${hours}h ${minutes}m ${seconds}s at ${nextEvent.height.toFixed(2)} ft`;
                } else {
                    nextTideDisplay.textContent = "No upcoming tide data available.";
                }
            }

            // --- EVENT LISTENERS ---
            document.getElementById('prev-day').addEventListener('click', () => {
                currentDate.setDate(currentDate.getDate() - 1);
                drawChart();
            });

            document.getElementById('next-day').addEventListener('click', () => {
                currentDate.setDate(currentDate.getDate() + 1);
                drawChart();
            });

            window.addEventListener('resize', drawChart);

            // --- INITIALIZATION ---
            drawChart();
        });
    </script>
</body>
</html>

